#!/usr/bin/env python
# vim: ts=3 sw=3 ai
#
#  Log information about incoming SMTP connections.
#
#  Copyright (c) 2004-2007, Sean Reifschneider, tummy.com, ltd.
#  All Rights Reserved
#  <jafo@tummy.com>

import sys, time, spf

try:
    from ipaddr import ip_address
except ImportError:
    # No PEP 3144 interface yet. Fall back.
    from ipaddr import IPAddress
    ip_address = IPAddress

from tumgreyspfsupp import prepare_start, DataDict, ParseException, InstanceCheck

# read config and prepare for start up
config, db = prepare_start(use_syslog=True, use_stderr=False)


def skip_ip(ip, ipaddrs):
    try:
        ip = ip_address(ip)
    except ValueError:
        return False
    
    for net in ipaddrs:
        if ip in net:
            return True
    return False


def spfcheck(data, config):
    queue_id = 'QUEUE_ID="%s"' % data.get('queue_id')
    
    try:
        ip = data['client_address']
    except KeyError:
        config.log_msg('spfcheck: No client address, exiting', 1)
        return (None, None)
    
    if skip_ip(ip, config['spfWhiteList']):
        return (None, 'SPF check N/A for whitelisted connections')

    try:
        sender = data['sender']
    except KeyError:
        sender = None
    
    try:
        helo = data['helo_name']
    except KeyError:
        if sender is None:
            config.log_msg('spfcheck: No sender or helo, exiting', 1)
            return (None, None)
        #  if no helo name sent, use domain from sender
        parts = sender.split('@', 1)
        try:
            helo = parts[1]
        except IndexError:
            helo = 'unknown'

    #  use the pySPF 2.0/RFC 4408 interface
    try:
        spfResult, spfReason = spf.check2(i=ip, s=sender, h=helo)
    except Exception, e:
        return ('prepend', 'TumGreySPF-Warning: SPF Check failed: %s' % str(e))

    spfResult = spfResult.strip().lower().capitalize()
    spfReason = spfReason.strip()
        
    if spfResult == 'None':
        #  allow checking to continue on to other checkers if no SPF
        return (None, None)
        
    if sender is not None:
        identity = 'mailfrom'
    else:
        identity = 'helo'
        
    spfDetail = 'identity=%s; client-ip=%s; helo=%s; envelope-from=%s; receiver=%s; ' % (
        identity,
        data.get('client_address'),
        data.get('helo_name'),
        data.get('sender'),
        data.get('recipient'),
    )
    config.log_msg('%s: %s; %s' % (spfReason, queue_id, spfDetail))
        
    if spfResult == 'Fail':
        return ('reject', '%s SPF Reports: %s' % (queue_id, spfReason))

    if spfResult == 'Permerror' and not config['spfAcceptOnPermError']:
        return ('reject', '%s SPF Reports: %s' % (queue_id, spfReason))

    if spfResult == 'Temperror':
        return ('defer', '%s SPF Reports: %s' % (queue_id, spfReason))
    
    # SPF validated mails can pass
    if spfResult == 'Pass' and config['spfBypassGreylist']:
        return 'pass', '%s SPF Reports: %s' % (queue_id, spfReason)

    return ('prepend', 'Received-SPF: %s (%s) %s' % (spfResult, spfReason, spfDetail))


def greylistcheck(data, config):
    greylist_data = {}
    search_criteria = {} 
    
    try:
        ip = data['client_address']
    except KeyError:
        return (None, None)
    
    # check if client is whitelisted
    if skip_ip(ip, config['greylistWhiteList']):
        return (None, 'greylist check N/A for whitelisted connections') 
    
    # meta data used to generate stats
    greylist_data['client_ip'] = int(ip_address(ip))
    
    if config['ignoreLastByte']:
        ipBytes = ip.split('.') 
        ipBytes[-1] = '0'
        ip = '.'.join(ipBytes)
    
    greylist_data['ip'] = int(ip_address(ip))
    search_criteria['ip'] = int(ip_address(ip))
    
    if not config['greylistByIPOnly']:
        try:
            greylist_data['sender'] = data['sender']
            search_criteria['sender'] = data['sender']
            greylist_data['recipient'] = data['recipient']
            search_criteria['recipient'] = data['recipient']
        except KeyError:
            return (None, None)

    allowTime = config['GREYLISTTIME']

    criteria = greylist_data.copy()
    db_data = db.greylist.find(search_criteria)

    if db_data.count() == 0: 
        greylist_data['changed'] = time.time()
        greylist_data['allowed_from'] = greylist_data['changed'] + allowTime
        
        # ensure there are no races in case data got inserted between check and now
        db.greylist.update(criteria, {"$set": greylist_data}, upsert=True)

        if config['defaultSeedOnly']:
            config.log_msg('Training greylisting: REMOTEIP="%s" HELO="%s" SENDER="%s" RECIPIENT="%s" QUEUEID="%s"' % (
                data.get('client_address'),
                data.get('helo_name'),
                data.get('sender'),
                data.get('recipient'),
                data.get('queue_id'),)
            )
            return (None, None)

        config.log_msg('Initial greylisting: REMOTEIP="%s" HELO="%s" SENDER="%s" RECIPIENT="%s" QUEUEID="%s"' % (
            data.get('client_address'),
            data.get('helo_name'),
            data.get('sender'),
            data.get('recipient'),
            data.get('queue_id'),)
        )
        
        return ('defer', 'Service unavailable, greylisted (http://projects.puremagic.com/greylisting/).')

    db_data = db_data[0]
    allowed_from = db_data['allowed_from']
    now = time.time()
    db.greylist.update({'_id': db_data['_id']}, {"$set": {'changed': now}}, upsert=True)
    if allowed_from > now and not config['defaultSeedOnly']:
        config.log_msg('Pending greylisting: REMOTEIP="%s" HELO="%s" SENDER="%s" RECIPIENT="%s" QUEUEID="%s"' % (
            data.get('client_address'),
            data.get('helo_name'),
            data.get('sender'),
            data.get('recipient'),
            data.get('queue_id'),)
        )

        return ('defer', 'Service unavailable, greylisted (http://projects.puremagic.com/greylisting/).')

    config.log_msg('Allowed greylisting: REMOTEIP="%s" HELO="%s" SENDER="%s" RECIPIENT="%s" QUEUEID="%s"' % (
            data.get('client_address'),
            data.get('helo_name'),
            data.get('sender'),
            data.get('recipient'),
            data.get('queue_id'),)
    )

    return (None, None)


def blackholecheck(data, config):
    try:
        ip = data['client_address']
    except KeyError:
        return (None, None)
    
    ip_data = {'ip': int(ip_address(ip)),}
    
    try:
        recipient = data.get('recipient')
    except KeyError:
        return (None, None)
    
    bh_data = {'address': recipient,}
    
    # check if mail goes to a "forbidden" address
    db_adresses = db.blackhole_adresses.find(bh_data)
    if db_adresses.count() > 0:
        # if it does then blacklist sender
        db.blackhole_ips.update(ip_data, ip_data, upsert=True)

    # finally check if sender is blocked
    if db.blackhole_ips.find(ip_data).count() > 0:
        config.log_msg('Blackholed: REMOTEIP="%s" HELO="%s" SENDER="%s" RECIPIENT="%s" QUEUEID="%s"' % (
                data.get('client_address'),
                data.get('helo_name'),
                data.get('sender'),
                data.get('recipient'),
                data.get('queue_id'),)
        )

        return ('reject', 'Service unavailable, blackholed.')

    return (None, None)


config.log_msg('Starting', 2)
    
instance_seen = InstanceCheck()
data = DataDict()

while 1:
    line = sys.stdin.readline()
    
    # exit if <STRG>-D is received
    if not line: 
        break
    
    line = line.rstrip()
    config.log_msg('Read line: "%s"' % line, 4)

    if line is '':
        config.log_msg('Found the end of entry', 4)

        checkerValue = None
        checkerReason = None
        for checker in config['checkers']:
            if checker == 'greylist':
                checkerValue, checkerReason = greylistcheck(data, config)
                if checkerValue is not None: 
                    break
            elif checker == 'spf':
                checkerValue, checkerReason = spfcheck(data, config)
                if config['spfSeedOnly']:
                    checkerValue = None
                    checkerReason = None
                if checkerValue is not None and checkerValue != 'prepend': 
                    break
            elif checker == 'blackhole':
                checkerValue, checkerReason = blackholecheck(data, config)
                if checkerValue is not None: 
                    break

        if checkerValue == 'reject':
            sys.stdout.write('action=550 %s\n\n' % checkerReason)
            
        elif checkerValue == 'prepend':
            # Only prepend data if instance has not been seen.
            if instance_seen(data):
                sys.stdout.write('action=dunno\n\n')
            else:
                sys.stdout.write('action=prepend %s\n\n' % checkerReason)
                
        elif checkerValue == 'defer':
            sys.stdout.write('action=defer_if_permit %s\n\n' % checkerReason) 
               
        else:
            sys.stdout.write('action=dunno\n\n')

        sys.stdout.flush()
        data = DataDict()
        continue

    try:
        data.parse_line(line)
    except ParseException:
        config.log_msg('ERROR: Could not match line "%s"' % line)
        continue
